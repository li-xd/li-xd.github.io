---
layout: post
title: "PHP.Type"
author: "XiaoDong.Li"
---

1. `Boolean` 类型
    
    被认为是 FALSE 的值:

    * 布尔值 FALSE 本身
    * 整形值 0
    * 浮点型值 0.0
    * 空字符串, 以及字符串’0’
    * 不包括任何元素的数组
    * 不包括任何成员变量的对象(仅 PHP 4.0 适用)
    * 特殊类型 NULL (包括尚未赋值的变量)
    * 从空标记生成的 SimpleXML 对象

1. Integer 整型

    整型的表达方式:

    * 使用八进制表达, 数字前面必须加 0
    * 使用十六进制表达, 数字前面必须加 0x
    * 使用二进制表达, 数字前面必须加 0b

    整型的常量值:
    * Integer 值的字长 PHP_INT_SIZE
    * Integer 值的最大值 PHP_INT_MAX

    八进制非法数字处理:
    * 如果向八进制数传递一个非法数字(8或9), 则后面其余数字会被忽略

    整数溢出:
    * 给定数超出了 Integer 的范围, 将会被解释为 float
    * 执行运算结果超出了 Integer 的范围, 将会返回 float

    转换为整型:
    * PHP 中没有整除的运算符
    * 将 Float 强转为 Integer 会舍弃小数部分强转
    * 将 Float 转换为 Integer 可以使用 round($val) 对数值四舍五入取整
    * round($val, $num) 保留位数的四舍五入, 后面的 $num 表示保留小数位数
    * round($val, $num, $mode) $mode 取值:
        - PHP_ROUND_HALF_UP 遇到.5的情况向上取整,
        - PHP_ROUND_HALF_DOWN 遇到.5的情况向下取整,
        - PHP_ROUND_HALF_EVEN 遇到.5的情况向偶数取整,
        - PHP_ROUND_HALF_ODD 遇到.5的情况向基数取整
    * ceil($val) 进一位取整
    * floor($val) 舍一位取整
    * intval($val, $base) 获取变量的整数值, $base 表示使用依照指定的进制转换
    * 将 BOOL 转换为 Integer FALSE 转换为 0, TRUE 转换为 1

1. String 字符串

    PHP 每个字符等同于一个字节, 因此不支持 Unicode, String 最大可以达到 2GB

    __一个字符串可以用4种表达式__:

    1. 单引号:
    
        要表示单引号本身, 需要它的前面加个 \ 来转义. 要表达一个反斜线本身, 需要使用 \\. 如果想使用其它转义序列如: \r 或者 \n, 并不代表任何特殊含义, 就单纯是这两个字符本身.
    1. 双引号: 将对一下字符进行解析
        * \n 换行
        * \r 回车
        * \t 水平制表符
        * \v 垂直制表符
        * \e Escape
        * \f 换页
        * \\ 反斜线
        * \$ 美元标记
        * \" 双引号
        * \[0-7]{1,3} 符合该正则表达式序列的一个以八进制方式来表达的字符
        * \x[0-9A-Fa-f]{1,2} 符合该正则表达式序列的一个以十六进制方式来表达的字符

        转义任何其他的字符都会导致反斜线被显示出来, 用双引号定义的字符串最重要的特征是变量会被解析.
    1. Heredoc 结构:
        * 以 <<< 开头, 之后接一个标识符, 然后换行, 接下来是 string 本身, 最后要用前面定义的标识符作为结束标志.
        * 不能用来初始化类的属性.(包含变量时)
        * 该结构转义与使用双引号字符串相同.
    1. Nowdoc 结构:
        * 以 <<< 开头, 之后接一个'标识符', 结构同 Heredoc.
        * 与 Heredoc 相比不进行解析操作.
        * 可以用在任何的静态数据环境中, 可以初始化类的属性和常量

    __变量解析, 分为两种形式__:

    1. 简单语法:
        * 当解析器遇到一个 $ 符号时, 去组合尽可能多的标识形成一个合法的变量名, 可以用花括号来明确变量的界限
        * 数组索引使用方括号 ] 来表示索引结束的边际, 对象使用 $对象->属性 的方式进行访问
    1. 复杂语法:
        * 任何具有 string 表达的标量变量, 数组单元或对象属性都可使用此语法. 只需简单的在 string 以外的地方那样写表达式. 然后用花括号 {} 把它括起来即可, {} 无法被解析, 只有紧挨着 $ 的 {} 才会被识别.
        * 函数, 方法, 静态类变量和类常量只能在 PHP 5 以后才可在 {$} 中使用.

    __存取和修改字符串中的字符__:

    * string 中的字符串可以通过一个从 0 开始的下标, 用法类似 array 结构中的方括号包含对应的数字来访问和修改.
    * string 可以替换 array[] 中的 [] 为 {} 访问.
    * 超出字符串长度的下标写入会拉长该字符串并以空格填充

    __转换为字符串__:

    * 一个值可以通过 string 强转或 strval() 函数来转换为字符串.
    * boolean 的 TRUE 被转换为 string 为 "1". FALSE 被转换为 string 的 "".
    * 一个 Integer 或 Float 被转换为数字的字面样式的 string.
    * 对象转换为 string 可以在 对象中使用 __toString() 方法.
    * resource 总被转换为 “Resource id #1” 这种结构的字符串, 其中的 1 是 PHP 在运行时分配给 resource 的唯一值.

    __字符串类型的解析__:

    * substr ($string, $start, $length) 返回一个字符串的子串
        * string: 输入的字符串
        * start : 
            * 非负情况, 返回字符串从 string 到 start 位置开始, 从 0 开始计算.
            * 负数情况, 返回字符串从 string 结尾处向前第 start 个字符开始.
            * string 的长度小于或等于 start 将返回 FALSE
        * length: 
            * 非负情况, 返回字符串从 start 处开始最多包括 length 个字符(取决于 string 的长度).
            * 负数情况, 从 string 末尾处的开始漏掉字符(若 start 是负数则从字符串尾部算起). 如果 start 不在这段文本中, 那么将会返回一个空字符串.
            * 如果提供一个值为 0, FALSE 或 NULL 的 length, 那么将返回一个空字符串.
            * 如果没有提供 length , 返回的子字符串将从 start 位置开始知道字符串结尾.
        * 返回值: 返回提取的子字符串， 或者在失败时返回 FALSE。
    * strpos ($haystack, $needle, $offset) 查找字符串首次出现的位置
        * haystack: 在该字符串中查找
        * needle: 如果 needle 不是一个字符串， 那么它将被转化为整形并被视为字符的顺序值
        * offset： 搜素从字符串该字符数的起始位置开始统计
        * 返回值: 返回 needle 存在于 haystack 字符串起始地位置， 如果没有找到 needle, 将返回 FALSE.
    * stripos ($haystack, $needle, $offset) 查找字符串首次出现的位置(不区分大小写)
    * strrpos ($haystack, $needle, $offset) 查找字符串最后一次出现的位置
    * strripos ($haystack, $needle, $offset) 查找字符串最后一次出现的位置(不区分大小写)
    * strstr ($haystack, $needle, $before_needle) 查找字符串首次出现
        * haystack 在该字符串中查找
        * needle 如果 needle 不是一个字符串， 那么它将被转化为整形并被视为字符的顺序值
        * before_needle 若是 TRUE, 将返回 needle 在 haystack 中的位置之前的部分， 否则默认返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串
        * 返回值: 返回上述字符串或者 FALSE(没有发现 needle).
    * stristr ($haystack, $needle, $before_needle) 查找字符串首次出现(不区分大小写)
    * strrchr ($haystack, $needle) 查找指定字符在字符串中最后一次出现 
        * haystack: 在该字符串中查找
        * needle: 
            * 如果 needle 包含了不止一个字符， 那么仅使用第一个字符
            * 如果 needle 不是一个字符串， 那么将被转化为整形并被视为字符顺序值
        * 返回值: 返回字符串的一部分， 如果 needle 未被找到， 返回 FALSE.
    * strpbrk ($haystack, $char_list) 在 haystack 字符串中查找 char_list 中的字符
    * strlen ($string) 获取字符串长度
    * strcmp ($str_1, $str_2) 二进制安全字符串比较
        * 返回值: 
            * 如果 str_1 小于 str_2 返回 < 0
            * 如果 str_1 大于 str_2 返回 > 0
            * 如果两者相等， 返回 0
    * strncmp ($str_1, $str_2, $len) 二进制安全比较字符串开头的若干个字符
    * strcasecmp ($str_1, $str_2) 二进制比较字符串(不区分大小写)
    * strncasecmp ($str_1, $str_2, $len) 二进制安全比较字符串开头的若干个字符（不区分大小写）
    * substr_compare ($main_str, $str, $offset, $length, $case_insensitivity) 二进制安全比较字符串(从偏移位置比较指定长度)
        * main_str： 待比较的第一个字符串
        * str: 待比较的第二个字符串
        * offset： 比较开始的位置， 如果为负数， 则从字符串结尾处开始算起
        * length: 比较的长度， 默认值为 str 的长度与 main_str 的长度减去位置偏移量 offset 后二者中的较大者
        * case_insensitivity： 默认为 false, 如果为 true, 比较将不区分大小写
        * 返回值: 
            * 如果 main_str 从偏移位置 offset 起的子字符串小于 str， 则返回 < 0
            * 如果 main_str 从偏移位置 offset 起的子字符串大于 str， 则返回 > 0
            * 如果 main_str 从偏移位置 offset 其的子字符串等于 str， 则返回 0
            * 如果 offset 大于等于 main_str 的长度或 length 被设置为小于 1 的值(PHP 5.6之前)， 函数打印警告并返回 FALSE.
    * strtoupper ($string) 将 string 中的所有字母字符转换为大写并返回
    * strtolower ($string) 将 string 中的所有字母字符转换为小写并返回
    * ucfirst ($string) 将 string 的首字母转换为大写
    * lcfirst ($string) 将 string 的瘦字母转换为小写
    * ucwords ($string) 将 字符串中的每个单词的首字母转换为大写

1. Array 数组

    PHP中的数组实际上是一个有序映射， 映射是一种把 values 关联到 keys 的类型，此类型在很多方面做了优化，一次可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多种可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。

    1. 定义数组
     array( key => value ,... ) 
        * 最后一个数组单元之后的逗号可以省略。
        * key 可以是 integer 或者 string 。value 可以是任意类型。
        * key 会进行如下的强制转换: 
            * 包含有合法整型值得字符串会被转换为整形。例如键名"8"实际会存储为8。但是"08"则不会强制转换，因为其不是一个合法的十进制数值。
            * 浮点数也会转换为整数，意味着其小数部分会被舍去。例如键名8.7实际上会被存储为8。
            * 布尔值也会被强转为整型。即键名为 true 实际上存储为1而键名为 false会被存储为0。
            * null会被转换为空字符串，即键名null实际会被存储为""。
            * 数组和对象不能被用为键名，如果使用会导致警告: Illegal offset type。
        * PHP 数组可以同时含有 integer 和 string 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。
        * 如果对给出的值没有指定键名，则取当前最大的整数索引值，而新的键名则是该值加一。如果指定的键名已经有了值，则该值会被覆盖。
        * 要删除某个键值对,对其调用 unset() 函数.
    1. 实用函数
        * unset() 函数允许删除数组中的某个键.但是注意数组将不能重建索引.
            * unset() 在函数中的行为会依赖于想要销毁的变量的类型而有所不同.
            * 如果在函数中 unset() 销毁一个全局变量,
            * 如果在函数中 unset() 一个全局变量,则只是局部变量被销毁,而在调用环境中的变量将会保持调用 unset() 之前一样的值.
            * 如果想要在函数中 unset() 一个全局变量, 可使用 $GLOBALS 数组来实现. 
     function foo () { unset($GLOBALS['bar']); } 
            * 如果在函数中 unset() 一个通过引用传递的变量,则只是局部变量被销毁,而在调用环境中的变量将保持调用 unset() 之前一样的值.
            * 如果在函数中 unset() 一个静态变量, 那么在函数内部此静态变量将被销毁.但是,当再次调用此函数时,此静态变量将被复原为上次被销毁之前的值.
            * (unset) 类型强转,是作为一个 NULL 类型的强制转换. 它不会改变变量的类型.
            * 因为是一个语言构造器而不是一个函数,不能被 可变函数 调用
            * 在 unset() 一个无法访问的对象属性时,如果定义了__unset() 则会调用这个重载方法.
        * empty () 检查一个变量是否为空 
            * 如果 var 是非空或非零的值,则 empty() 返回 FALSE.
            * "", 0, "0", NULL, FALSE, array(), var $var 以及没有任何属性的对象都将被认为是空的.
            * 除了当变量没有设值时不产生警告以外, empty 是 (boolean)var 的反义词.
        * array_values() 函数可以重新建立索引.
    1. 转换为数组
        * 对任意 integer, float, string, boolean 和 resource 类型,如果将一个值转换为数组,将得到一个仅有一个元素的数组,其下标为0,该元素即为此标量的值.换言之, (array)$val 与 array($val)完全一样.
        * 如果一个 object 类型转换为 array, 则结果为一个数组,其单元为该对象的属性.键名将为成员变量名, 不过有几点例外: 
            * 整数属性不能访问
            * 私有变量前面会加上类名作为前缀
            * 保护变量前面会加上一个 '*' 做前缀.
            * 这些前缀的前后都各有一个 NULL 字符, 这会导致一些不可预知的行为.
        * 将 NULL 转换为 array 会得到一个空的数组.

1.  Object 对象

    1. 转换为对象 
        * 如果将一个对象转换成对象, 它将不会有任何变化.
        * 如果其他任何类型的值被转换成对象, 将会创建一个内置类 stdClass 的实例.
        * 如果该值为 NULL,则新的实例为空.
        * 数组转换成对象将使键名成为属性名并具有相应的值.
        * 对于任何除数组意外的值,名为 scalar 的成员变量将包含该值.

1. NULL

    特殊的NULL值表示一个变量没有值.NULL类型唯一可能的值就是NULL.
    1. 一个变量被认为是NULL的情况:
        * 被赋值为 null.
        * 尚未被赋值
        * 被 unset().
    1. 语法

        NULL 类型只有一个值, 就是不区分大小写的常量NULL.
    1. 转换到 NULL

        使用 (unset)$var 将一个变量转换为 null 将不会删除该变量或 unset 其值. 仅是返回 NULL 而已.


1. Callback 回调类型

    1. create_function() 可以用来创建一个匿名回调函数: 
        * string create_function(string $agrs, string $code);
        * 返回值会是一个函数名称
        * 被匿名函数取代
    1. closure 匿名函数
        * 普通定义： 
        $fun = function($name) { var_dump($name); } 

        * 从父作用域中继承变量
        $fun = function($name) use ($message) { } 
        这个 $message 在父作用域是什么值在继承定义时就是什么值，调用时更改父作用域的该值没有效果。

        * 从父作用域中继承可变变量（继承值可变）
     $fun = function($name) use (&$message) { } 
    1. 回调函数的基本用法 
        * call_user_func(‘方法名称’);
        * call_user_func(array(‘类名’, ‘静态方法名称’));
        * call_user_func(array(‘对象’, ‘对象方法名称’));
        * call_user_func(‘类名::静态方法名称’);
        * call_user_func(‘回调函数’, 参数);
        * call_user_func_array(‘回调函数’, 参数数组);
        * 如果前一个回调中有未捕获的异常，其后的将不再被调用。

1. 类型转换的判别

    1. 自动类型转换’+’运算符为例: 
        1. 如果任何一个操作数是 float, 则所有的操作数都被当成 float，结果也是 float。
        1. 否则操作数会被解析为 integer， 结果也是 integer。
    1. 类型强制转换 
        1. 强转方式: 
            * 在要强转的变量之前加上用括号括起来的目标类型。
        1. 允许的强制转换有: 
            * (int), (integer) - 转换为整型 integer
            * (bool), (boolean) - 转换为布尔类型 boolan
            * (float), (double), (real) - 强转为浮点型 float
            * (string) - 转换为字符串 string
            * (object) - 转换为对象 object
            * (unset) - 强转为 NULL