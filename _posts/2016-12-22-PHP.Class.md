---
layout: post
title: "PHP.Class"
author: "XiaoDong.Li"
---

1. 基本概念

    1. new
        * 在类定义内部,可以用 new self 和 new parent 创建新的对象.
    2. extends
        * 被继承的方法和属性可以通过用同样的名字重新声明被覆盖.但是如果父类定义方法时使用了 final, 则该方法不可被覆盖.可以通过parent::来访问被覆盖的方法或属性.
        * 当覆盖方法时,参数必须保持一致.但是构造函数除外.
    3. ::class
        * 使用 ClassName::class 可以获取一个字符串,包含了类 ClassName 的完全限定名称.
2. 自动加载类

    __autoload() 函数, 他会在试图使用尚未被定义的类时自动调用.通过调用此函数,脚本引擎在PHP出错失败前有最后一个机会加载所需的类.
3. 构造函数和析构函数

    1. 构造函数
        * 如果子类中定义了构造函数则不会隐式调用其父类的构造函数.要执行父类的构造函数,需要在子类的构造函数中调用parent::__construct().如果子类没有定义构造函数则会如果一个普通的方法一样从父类继承.
        * 如果在类中找不到 __construct() 函数并且也没有从父类继承一个的话,就会尝试寻找旧式的构造函数.也就是和类同名的函数.
        * 当父类的构造函数与本类的不同时,PHP不会报错,是合法的.
    2. 析构函数
    __destruct(void)
        * 和构造函数一样,父类的析构函数不会被引擎暗中调用.要执行父类的析构函数,必须在子类的析构函数中显示调用 parent::__destruct().此外也和构造函数一样,子类如果自己没有定义析构函数则会继承父类的.
        * 析构函数即使在使用 exit() 终止脚本运行时也会被调用.在析构函数中调用 exit() 将会中止其余关闭操作的运行.
        * 试图在析构函数中抛出一个异常会导致致命错误.
4. 访问控制

    如果没有设置访问关键字(公有, 私有, 保护).则该方法默认为公有.
5. Traits

    * Trait 和一个类相似,但仅仅旨在用粒度和一致的方式组合功能.Trait不能通过它自身来实例化.它为传统继承增加了水平特征的组合;应用类的成员不需要继承.
    * 优先级:
        从基类继承的成员被 trait 插入的成员所覆盖.优先顺序来自当前类的成员覆盖了 trait 的方法.而 trait 则覆盖了被继承的方法.
6. 重载

    1. 属性重载
        * PHP 所提供的 “重载” 是指动态地 “创建” 类属性和方法.
        * 当调用当前环境下未定义或不可见的类属性或方法时,重在方法会被调用.
        * 所有的重载方法都必须被声明为 public.

        1. 在给不可访问属性赋值时, __set() 会被调用.

            public void __set(string $name, mixed $value); 
        2. 读取不可访问属性的值时, __get() 会被调用.

            public mixed __get(string $name); 
        3. 当对不可访问属性调用 isset() 或 empty()时, __isset() 会被调用.

            public bool __isset(string $name); 
        4. 当对不可访问属性调用 unset() 时, __unset() 会被调用.

            public void __unset(string $name); 

        * 属性重载只能在对象中进行. 在静态方法中,这些魔术方法将将不会被调用.所以这些方法都不能被声明为 static.
        * 因为 PHP 处理赋值运算的方式, __set() 的返回值将被忽略, 类似的, 在链式赋值中, __get()不能被调用.
        * 在除isset()外的其他语言结构中无法使用重载属性,这意味着当对一个重载的属性使用 empty() 时, 重载魔术方法将不会被调用.
        * 必须将重载属性赋值到本地变量再使用 empty().

    2. 方法重载
        1. 在对象中调用一个不可访问的方法时, __call() 会被调用.

            public mixed __call(string $name, array $arguments); 
        2. 在静态方法中调用一个不可访问方法时, __callStatic() 会被调用.

            public static mixed __callStatic(string $name, array $arguments); 
7. 魔术方法

    1. __sleep() 和 __wakeup()
        * serialize() 函数会检查类中是否存在一个魔术方法 __sleep(). 如果存在, 该方法会先被调用.然后才执行序列化操作.此功能可以用于清理对象,并返回一个包含对象中所有应被序列化的变量名称的数组.
        * __sleep() 方法常用于提交未提交的数据,或类似的清理操作.
        * unserialize() 函数会检查是否存在一个 __wakeup 方法. 如果存在, 则会先调用 __wakeup() 方法, 预先准备对象需要的资源.
        * __wakeup() 经常用在反序列化操作中, 如重新建立数据库.
    2. __toString()
        * __toString() 方法用于一个类被当成字符串时应怎样回应.
        * 不能再 __toString() 方法中抛出异常,这样会导致致命错误.
    3. __invoke()
        * 当尝试以调用函数的方式调用一个对象时, __invoke() 方法会被自动调用.
    4. __set_state()
        * 当调用 var_export() 导出类时, 此静态方法被调用.
     static object __set_state(array $properties) 
    5. __debugInfo()
        * 当调用 var_dump() 显示一个类信息时, 会被调用.
8. Final 关键字

    如果父类中的方法被声明为 final, 则子类无法覆盖该方法,如果一个类声明为 final, 则不能被继承.
    属性不能被定义为 final, 只有类和方法才能被定义为 final.
9. 类型约束

    函数的参数可以指定必须为对象,接口,数组或者callable. 不过如果使用 NULL 作为参数的默认值,那么在调用函数的时候依然可以使用NULL 作为实参.
    如果一个类或接口指定了类型约束,则其所有的子类或实现也都如此.
    类型约束不能用于标量类型如 int 或 string. Traits 也不允许.
10. 后期静态绑定

    static:: 不再被解析为定义当前方法所在的类,而是在实际运行时计算的.也可以称之为”静态绑定”,因为它可以用于静态方法的调用.
    后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止.